# 数据结构与算法

## 第一章 绪论

### 1.1 数据结构的基本概念

​		**数据**：对客观事物的符号化表示，是计算机程序加工的原料，数据的基本单位是数据元素。

​		**数据结构**是相互存在一种或多种特定关系的数据元素的集合。有四种基本结构：（1）**集合** 结构中的数据元素没有关系；（2）**线性结构** 结构中的数据元素只有一个前驱或者后继（端节点除外）；（3）**树形结构** 数据元素的关系图满足图论的树图；（4）**图状结构（网状结构）** 数据元素之间存在着多个对多个的关系。

​		数据结构可以用关系图来表示，节点代表数据元素的有限集、边代表元素之间的关系、这种表示法表示的是数据结构的数学模型，称为**逻辑结构**。此外，数据结构在计算机中还要存储元素之间的关系，数据结构在计算机中的表示称为数据的**物理结构**。物理结构在计算机中有两种存储法：**顺序存储结构**与**链式存储结构**。顺序存储结构按照元素在存储器中的相对位置来进行存储，有顺序；链式存储结构中还要存储**指针**来表示元素之间的关系：

<img src="https://gitee.com/you-xu2003/markdown-pic/raw/master/img/202302211857451.png" alt="Alt" style="zoom:10%;" />

​		数据类型：可分为原子类型（整型、实型、字符型、枚举型）和结构类型。**抽象数据类型**是指一个数学迷行以及定义在该模型上的一组操作。

### 1.2 算法和算法分析

算法是对特定问题求解步骤的一种描述，是指令的有限序列。算法的五个特性：

1. 有穷性，一个算法必须在又穷的时间内完成，这里的有穷时间是针对人的可以接受的时间长度。
2. 确定性，不能产生二义性。
3. 可行性。
4. 输入。
5. 输出。

#### 1.2.1 算法的效率

（1）输入一个整数值N设计一个程序打印从0到N的所有整数值的程序，有以下两种方式：

```c
/*直接法*/
void printN(int N)
{
    int i;
    for(i=0; i<=N; i++){
        printf("%d\n", i);
    }
    return;
}
/*递归法*/
void printN(int N)
{
    if(N){
        printN(N-1);
        printf("%d\n", N);
    }
    return;
}
```

这两个实现方法实际上拥有不同的空间效率，递归的方法占用的空间实际上相当之大。

（2）写一个程序计算给定多项式$f(x)=\sum\limits_{i=0}^{9}a_ix^i$在某一定点的数值：

```c
double f1(int n, double a[], double x)
{
    int i;
    double p = a[0];
    for(i=1; i<=n; i++)
    {
        p += (a[i]*pow(x, i));
    }
    return p;    
}
```

将多项式$f(x)=a_0+a_1x=a_2x^2+...+a_nx^n$写成$f(x)=a_0+x(a_1+x(...(a_{n-1}+x(a_n))...))$可以将程序写成下面的样子

```c
double f2(int n, double a[], double x)
{
    int i;
    int p = a[n];
    for(i=n; i>0; i--){
        p = a[n-1] + p*x;
    }
    return p;
}
```

那么。这两种算法哪一个更好呢？判断一个算法“好不好”，主要看它的效率怎样，实际上，这第二种算法时间上的效率要优于第一种算法。我们可以用C中计时器加以验证：

```c
#include <stdio.h>
#include <time.h>

clock_t start, stop;
/* clock_t是clock()函数的返回值类型*/
double duration;

int main()
{
    /* 不在测试范围内的准备工作写到clock()调用之前 */
    start = clock(); // 开始计时
    MyFunction();
    stop = clock(); // 停止计时
    duration = ((double)(stop - start))/CLK_TCK; //CLK_TCK是机器自带常数，反映的是一秒之内计时器tick的次数
    return 0;
}
```

对于一些函数运行起来很快，甚至用不到一个tick，那么计算的结果都将是0。我们通过重复运行该函数的方法，累积出时间再除以运行次数

```c
#include<stdio.h>
#include<time.h>
#include<math.h>
clock_t start, stop;
double duration;
#define MAXK 1e7
int main()
{
    start = clock();
    for(i=0; i<MAXK; i++){
        f1(MAXN-1, a, 1.1);
    }
    stop = clock();
    duration = ((double)(stop-start))/CLK_TCK/MAXK;
    printf("ticks = %f\n", ticks);
    printf("duration = %6.2e\n", duration);
    /*f2同样*/
    return 0;
}
```

从理论上分析，第一种方法在循环中会计算$\dfrac{n^2+n}{2}$次乘法，而第二种方法只需要做n次乘法就够了，所以第二种方法优于第一种方法。

**算法效率的度量**：时间复杂度T(n)和空间复杂度S(n)

时间复杂度：
$$
T(n)=O(f(n))
$$
表示存在常数C>0，$n_0>0$使得当$n>n_0$时有$T(n)\leq Cf(n)$。对充分大的n而言$f(n)$是一个上界。算法执行的时间与$ O(f(n)) $成正比。决定T(n)的是控制语句`while`和`for`。**一个`for`循环的时间复杂度等于循环次数乘以循环体代码的复杂度；`if-else`结构的复杂度取决于if的条件判断复杂度和两个分支部分的复杂度，总体复杂度取三者中最大。**

**注：**

1. 在设计程序时，应尽量避免出现f(n)为指数函数、阶乘函数的算法。
2. 设计出复杂度为$O(n^2)$的算法时，可以去想一想是否可以将复杂度降为$O(n\log n)$。
3. $\log n$的底数无关紧要，不同的底数相差的只是倍数。

关于时间复杂度的性质有如下几条：
$$
\begin{align}
O(f(n)+g(n))&=max\{O(f(n)),O(g(n))\}\\
O(cf(n))&=O(f(n))\\
O(f(n))O(g(n))&=O(f(n)g(n))
\end{align}
$$
时间复杂度的例子会在以后设计算法的过程中一一计算。

求多项式第二个方法的时间复杂度$T(n)=C_1n^2+C_2n$，第二个方法的时间复杂度为$T(n)=Cn$。

空间复杂度：
$$
S(n)=O(f(n))
$$
一个算法在运行过程中临时占用存储空间大小的量度，在之后学习到的排序算法会有具体的讲解。

分析一般的算法效率时，我们经常关注两种复杂度：最坏情况复杂度和平均复杂度$T_{average}(n)<T_{worst}(n)$

### 1.3 抽象数据类型（Abstract Data Type）

描述数据类型的方法**不依赖于具体的实现**，只描述数据对象集和操作集具体是什么，不关心怎么做到的。

### 1.4 二分查找算法

给定N个从小到大排好序的整数序列`List[]`以及某待查找整数X，寻找X在List中的下标，即若有`List[i]=x`，则返回i；否则返回-1表示没有找到。二分法是先找到序列的中点List[M]，与X进行比较，若相等则返回中点下标；否则，若`List[M]>X`，则在左边的子序列中查找X；若`List[M]<X`，则在右边的子序列中查找X，不断的重复下去。

伪码描述：

```c
right = sizeof(arr)/sizeof(arr[0]) - 1;
left = 0;
while(right>left){
    mid = left + (right - left)/2; //寻找最中间的数
    if(x < arr[mid])
    {
        right = mid - 1;
    }
    else if(x > arr[mid]){
        left = mid + 1;
    }
    else if(x = arr[mid]){
        print(mid);
    }
}
if(right<left)
    return -1;
return 0;
```

该算法的最好情况是查找1次，最坏情况是查找的元素在最后。对于n个元素的状况：

1. 第1次二分剩下的元素：n/2
2. 第2次二分剩下的元素：n/4
3. ...
4. 第k次二分剩下的元素：n/2^k

最坏的情况剩下的元素为1，即$2^k=n$，$k=\log n$。空间复杂度，由于辅助空间是常数，故为$O(1)$。

### 1.5 应用实例——最大子列和问题

给定N个整数的序列$\{A_1,A_2,...,A_N\}$，求函数$f(i, j)=\max\{0,\sum\limits_{k=1}^j A_k\}$的最大值。

算法一，暴力求解

```c
int MaxSubseqSum1(int A[], int N)
{
    int ThisSum, MaxSum = 0;
    int i, j, k;
    for(i=0; i<N; i++){
        
        for(j=i; j<N; j++){
            ThisSum = 0;
            for(k=i; k<=j; k++)
                ThisSum += A[k];
            
            if(ThisSum > MaxSum)
                MaxSum = ThisSum;
            
        }        
    }
 return MaxSum;   
}
```

这个算法是不可以被设计使用的，因为它的时间复杂度达到$O(N^3)$，当子列有10000个元素时，这个算法到了世界末日也完不成。可是，10000在大数据领域是一个微不足道的小数字。

该算法的缺陷在于再计算以相同开头的子列和时，有相当多的和式被重复计算了。改进这个算法就可以从避免重复计算入手

```c
int MaxSubseqSum1(int A[], int N)
{
    int ThisSum, MaxSum = 0;
    int i, j, k;
    for(i=0; i<N; i++){
        ThisSum = 0;
        for(j=i; j<N; j++){
            ThisSum += A[j];           
            if(ThisSum > MaxSum)
                MaxSum = ThisSum;            
        }        
    }
 return MaxSum;   
}
```

这个算法的时间复杂度降到了$O(N^2)$是个不小的飞跃，一般来讲时间复杂度为$N^2$的算法，常常有机会降到$N\log N$。下面来介绍优化算法——分治法。

<img src="https://gitee.com/you-xu2003/markdown-pic/raw/master/img/202303022328063.jpg" alt="微信图片_20230302232803" style="zoom: 50%;" />!]

```c
int Max3(int x, int y, int z)
{
    return x>y?(x>z?x:z):(y>z?y:z);
}
int DivCon(int list[], int left, int right)
{
    int MaxSumL, MaxSumR;//存放左右子问题的解
    int MaxSumBordL, MaxSumBordR; //存放跨分界线的结果
    int SumBordL, SumBordR;
    int center, i;
    
    if(left == right)
    {
        /*递归的终止条件，子列只有一个数字，此时，左等于右*/
        if(List[left]>0)
            return List[left];
        else
            return 0;
    }
    
    /*下面是分的过程*/
    center = (left+right)/2; //找到中分点
    MaxSumL = DivCon(List, left, center); //递归求两边子列的最大和
    MaxSumR = DivCon(List, center, right);
    
    /*下面求跨分界线的最大子列*/
    MaxSumBordL = 0;
    SumBordL = 0;
    
    for(i=center; i>=left; i--){
        SumBordL += list[i];
        if(SumBordL>MaxSumBordL)
            MaxSumBordl = SumBordL;
    }
    
    MaxSumBordR = 0;
    SumBordR = 0;
    for(i=center+1; i<=right; i++){
        SumBordR += list[i];
        if(SumBordR>MaxSumBordR)
            MaxSumBordR = SumBordR;
    }
    
    /*下面返回“治”的结果*/
    return Max3(MaxSumL, MaxSumR, MaxSumBordL+MaxSumBordR);
}

int MaxSeqSum3(int List[], int N)
{
    return DivCon(List, 0, N-1);
}
```

**分治法的时间复杂度**

由算法步骤可知：
$$
\begin{align}
T(N)&=2T(\frac N 2)+cN\\
T(1)&=O(1)
\end{align}
$$

$$
\begin{align}
T(N)&=2[2T(\dfrac N {2^2})+c\dfrac N 2]+cN\\
&=\cdots\\
&=2^kT(\frac{N}{2^k})+ckN
\end{align}
$$

当$2^k=N$时，
$$
T(N)=NO(1)+cN\log N
$$

$$
T(N)=cN\log N=O(N\log N)
$$

**分治法的空间复杂度**

递归函数的空间复杂度=单次递归的空间复杂度*递归深度。整体空间复杂度＝存储List的空间+递归空间复杂度。

按照C的代码，可知，每递归一次，list长度减少一半，直至减少到1为止，设递归深度为k：
$$
\dfrac{N}{2^k}=1\\
k=\log_2 N
$$
每次递归需要的辅助空间是常数级的，因此$S(n)=O(CN\log N)=O(N\log N)$，总体空间复杂度=$O(N\log N)+O(N)=O(N\log N)$。

更快的算法：在线处理算法

```c
int MaxSubseqSum4(int A[], int N)
{
    int ThisSum, Maxsum;
    int i;
    ThisSum = MaxSum = 0;
    for(i=0; i<N; i++){
        ThisSum += A[i];
        if(ThisSum > MaxSum)
            MaxSum = ThisSum;
        else if(ThisSum<0) //无比精妙，如果ThisSum<0，那么不能使后面的部分和增大，后面的部分和是i++之后的下一步循环，加上这个ThisSum才是只有这一轮才有的子列，所以有必要对其讨论，然而这个ThisSum<0加上它已经比下一轮循环的子列和小了，因此没有讨论的必要了。
            ThisSum = 0;
    }
    return MaxSum;
}
```

$T(n)=O(N)$.

## 第二章 线性表

### 2.1 线性表的定义

线性表就是线性的数据结构，应注意，线性表的数据元素必须**属于同一数据对象**，即具有相同特性。如字母表，统计表。

线性表的操作包括插入、删除、访问和查找，用程序实现线性表有两种方法，各有合适的适用范围。**顺序实现（顺序表）和链式实现（链表）**

### 2.2 线性表的顺序实现

顺序表通常用数组来表示，线性表的长度是可变的，故在C语言中，要用动态分配的一维数组。

```c
#define LIST_INIT_SIZE 100 //线性表存储空间的初始分配量
#define LISTINCREMENT  10 //线性表存储空间的分配增量
typedef struct{
    ElemType *elem; //存储空间基本地址
    int length; //当前长度
    int lengthsize; //当前分配的存储容量
}SqList;

/*另一种常用的定义方法*/
typedef int Position;
typedef struct LNode{
    ElemType Data[MAXSIZE];
    Position Last;
}LNode, *List;
```

为顺序表增加存储空间用`status`作为抽象的返回类型，用以说明函数运行的成功或失败状态。

#### 顺序表元素的初始化

**定义类型为一**

```c
Status InitList_Sq(SqList &L)
{
	L.elem = (ElemType*)malloc(LIST_INIT_SIZE*sizeof(ElemType));
    if(!L.elem)
        exit(OVERFLOW); //操作系统无法为程序员申请一块这样的内存，会返回一个0，这块内存是不被允许访问的
    L.length = 0; //空表长度为0
    L.listsize = LIST_INIT_SIZE; // 初始存储容量
    rerurn OK;
}
```

**定义类型为二**

```c
List MakeEmpty()
{
    List L;
    L = (List)malloc(sizeof(struct LNode));
    L->Last = -1;
    return L;
}
```

#### 顺序表元素的查找

**定义类型一**

```c++
int ListSearch(SqList L, int e)
{
    int i;
    for(i=1; i<L.length; i++){
        if(L.elem[i-1] == e)
            rerurn i;
    }
        return -1;
}
```

该算法的时间复杂度为$O(n)$,如何进行算法的优化？只能从语句`i < L.length`入手，我们可以先将数组的元素整体向下平移一格，空出索引值为0的位置，并在此处填上要索引的值。

```c
int ListSearch(SqList* L, int e)
{
    if (L -> length >= L -> listsize) {
        int* newbase = (int*)realloc(L -> elem,
            (L -> listsize + LISTINCREMENT) * sizeof(int));
        L->elem = newbase;
    }
    

    int* p = &(L->elem[L->length - 1]);
    for (p; p >= L->elem; p--) {
            *(p + 1) = *p;
        }
    L -> elem[0] = e;
    ++L -> length;
    int i;
    for (i = L -> length; L->elem[i] != e; i--);
    return i;
}
```

**定义类型二**

```c
Position Find(List L, Elemtype X){
    Position i = 0;
    while(i<=L_>Last && L->Data[i]!=x)
        i++;
    if(i>L->Last)
        return ERROR;
    else 
        return i;
}
```



#### 顺序表元素的访问：

```c
L.elem[i-1]; //访问链表中的第i个元素
L.data[i-1];
```

#### 顺序表元素的插入：

**定义类型为一**

首先定义一个可插入顺序表的前提是要保证当前长度`L.length`小于当前分配的存储容量`L.listsize`

<img src="https://gitee.com/you-xu2003/markdown-pic/raw/master/img/202302231828275.png" style="zoom:50%;" />

想要在2、3之间插入元素25，采用引入辅助变量交换元素的方法空间复杂度大，也很复杂，采用**从后向前，将元素下移，直到把3的位置空出来留给25

```c++
Status ListInsert_Sq(SqList &L, int i, elemType e){
    if(i<1 || i>L.length-1) return ERROR; //超出索引值，不合法
    
    if(L.length>=L.listsize){ //当前存储空间已满，增加分配
        newbase = (ElemType*)realloc(L.elem, L.listsize+LISTINCREMENT)*sizeof(Elemtype));
    }
    
    if(!newbase)exit(OVERFLOW); //存储分配失败
    
    L.elem = newbase; //新基址
    L.listsize += LISTINCREMENT; //增加存储容量
}

q = &(L.elem[i-1]); //获取要插入的位置
for(int p=&(L.elem[L.length-1]); p>=q; --p){
    *(p+1) = *p;
}

*q = e; //插入e
++L.length; //表长加一

return OK;
```

**定义类型为二，在第**$i(i\leq i\leq n+1)$ **个位置上插入一个值为X的新元素**

```c
typedef struct LNode{
    ElemType Dta[MAXSIZE];
    int Last;
}L, *List;
List PtrL;
void Insert(ElemType X, int i, List PtrL)
{
    int j;
    if(PtrL->Last == MAXSIZE-1) //线性表满，不能插入
    {
        printf("表满");
        return;
    }
    if(i<1||i>PTrL->Last+2){
        printf("Illegal!");
        return;
    }
    for(j=PtrL->Last; j>=i-1; j--)
        PtrL->Data[j+1] = PtrL->Data[j];
    PtrL->Data[i-1] = x;
    PtrL->Last ++;
    retturn ;
}
```



#### 顺序表元素的删除

**定义类型为一**

删除第i个元素需要将从第i+1至第n个元素依次向前移动一个位置：

```c
Status ListDelete_Sq(SqList &L, int i, ElemType &e)
{
    if(i<=1 || (i>L.length))
        return Error; // 超出索引值，不合法
    
    int *p = &(L.elem[i-1]);
    e = *p; // 记录删除的值
    
   int* q = &(L.elem+L.length-1);
    for(++p; p<=q; p++){
        *(p-1) = *p;
    }
    
    --L.length;
    return OK;
}
```

**时间复杂度分析**

插入与删除算法耗费在对元素的移动上，移动元素的个数则取决于插入或删除元素的位置。

假设$p_i$是在第$i$个元素之前插入一个元素的概率，则在长度为n的线性表中插入一个元素时所需移动元素次数的期望值为
$$
\begin{equation}
E_{is}=\sum\limits_{i=1}^{n+1}p_i(n-i+1)
\end{equation}
$$
假设$q_i$是删除第$i$个元素的概率，则在长度为n的线性表中删除一个元素时所需移动次数的期望值为
$$
E_{dl}=\sum\limits_{i=1}^{n}q_i(n-i)
$$
通常情况下，在任何位置插入或删除元素的概率都是相等的，即
$$
p_i=\dfrac{1}{n+1}, \quad q_i=\dfrac{1}{n}
$$
化简期望：
$$
\begin{align}
E_{is}&=\dfrac{1}{n+1}\sum\limits_{i=1}^{n+1}(n-i+1)=\dfrac n2\\
E_{dl}&=\dfrac 1n\sum\limits_{i=1}^n(n-i)=\dfrac{n-1}2
\end{align}
$$
无论是插入还是删除，都平均需要移动n/2个元素，因此$T(n)=O(n)$。

**定义类型为二**

```c
bool Delete(List L, Position P)
{
    Position i;
    id(p<0 || P>L->Last){
        prinf("位置%d中不存在元素！", P);
        return False;
    }
    for(i=P+1; i<=L->Last; i++){
        L->Data[i-1] = L->Data[i]; //将删除元素(P+1)后方的元素依次向前移动。
    }
    L->Last --;
    return True;
}
```





### 2.3 链表(Link List)

![image-20230227161932079](https://gitee.com/you-xu2003/markdown-pic/raw/master/img/202302271619265.png)





数据以及下一个存放地址的组合称为结点(node)，每个结点的地址是无规律的，只靠着地址将其串联起来。在单链表的索引中，取得第i个元素必须从头指针出发。

**头指针** 指向链表的第一个节点的结点称为头结点，头结点的指针域称为头指针。头结点可以不存放任何的数据信息，也可以存放链表的基本信息，头指针是必须存在的，而且一旦被头指针指向后，被头指针指向的结点就不允许进行删除、插入操作。当头指针为NULL（空）是，该链表为空表。

**单链表的存储结构**

```c++
typedef struct LNode{
    ElemType data; // 链表存储的数据
    struct LNode *next; // 指向下一个元素的指针
}LNode, *LinkList;
```

#### 求链表长度

```c
int Length(LinkList PtrL)
{
    LinkList p = PtrL;
    int j = 0;
    while(P){
        p = p->next;
        j++;
    }
    return j;
}
```

#### 查找

**按序号查找** ：链表的时间复杂度要大于数组的时间复杂度。

```c
LinkList FindKth(int K, LinkList PtrL)
{
    LinkList p = PtrL;
    int i = 1;
    while(p!=NULL && i<K){
        p = p->next;
        i++;
    }
    if(i==K)
        return p;
    else //p = NULL
        return NULL;
}
```

**按值查找**：链表的时间复杂度等同于数组的时间复杂度。

```c
LinkList Find(ElemType X, LinnkList PtrL)
{
    LinkList p = PtrL;
    while(p!=NULL && p->Data != X)
        p = p->next;
    return p;
}
```

#### 单链表的插入操作

相比于数组，链表的插入操作不需要移动数据。

（1）在线性单链表的p结点之后插入一个新的结点x

```c
void insert(LinkList &p, int x)
{
    LinkList s;
    s = (LinkList)malloc(sizeof(LNode)); // 生成结点空间s
    s -> data = x; //插入的数据x放入结点空间s
    /*注意赋值的顺序*/
    s -> next = p -> next; //首先要将p原来的后继记录在插入元素x的结点空间
    p -> next = s; //再把元素x的结点空间的地址插入到p
}
```

（2）在头指针为h的带表头结点的单链表中数据元素a之后插入新的数据元素b

```c
void insert_S(Linklist &p, int a)
{
    p = search(h, a);
    if(p != NULL)
        insert(p, b);
}
```



#### 单链表的删除操作

（1）删除单链表中p结点的直接后继结点

```c
void delete(LinkList &p)
{
    LinkList q;
    q = p -> next;
    p -> next = q -> next;
    free(q);
}
```

(2)在头指针为h的带表头结点的单链表中删除**元素x**

```c
void delete1(LinkList &h, int x)
{
    LinkList p = h -> next;
    q = h;
    while(p != NULL){
        if(p -> data == x){
            q -> next = p -> next;
            free(p);
            return;
        }
        else{
            q = p; 
            p = p -> next;
        }
    }
}
```

(3)删除重复结点：

在(2)的基础上稍作改动

```c
void delete3(LinkList &h, int x)
{
    LinkList p = h -> next;
    q = h;
    while(p != NULL)
    {
        if(p -> data == x){
            q -> next = p -> next;
            free(p);
            p = q -> next; // 继续走下去
        }
        else{
            q = p;
            p = p -> next;
        }
    }
}
```

**设链表中的元素以递增序存储，用类C语言设计高效算法删除其中大于等于mink且小于等于maxk的元素 **

```c
/*带表头节点，且链表应升序排列*/
Status delete_scale(LinkList &h, ElemType mink, ElemType maxk)
{
    if(mink>maxk){
        printf("ERROR! mink should be less than maxk!")
            exit(-1);
    }
    p = h;
    q = h;
    
    while(p->next->data!=mink && p->next->next)
        p = p->next;
    while(q->data!=maxk && q)
        q = q->next;   
    
    if(q == NULL) //找不到最大值出现的位置
        printf("ERROR! Maxk is not in the list!");
    else (p->next==q) 
        p->next = q->next;   
}
```



#### 单链表的就地逆置

<img src="https://gitee.com/you-xu2003/markdown-pic/raw/master/img/202303022253603.png" alt="image-20230302225325370" style="zoom:80%;" />

```c
void reverse(LinkList &h)
{
    LinkList p, q;
    if(h->next == NULL) return;
    if((h->next)->next == NULL) return;
    
    p = h->next->next;
    (h->next)->next = NULL; //执行Step 1
    while(p!=NULL){
        q = p;
        p = p->next; //移位，为下一周期执行做准备，停止条件为p != NULL
        q->next = h->next;
        h->next = q; //执行Step 2,特别注意12、13行的代码顺序
        
    }    
}
```

**循环单链表的就地逆置**

```c
void reverse_cir(LinkList* h)
{
    LinkList* p = h;
    LinkList* q = h;
    if (h->next == NULL)
        return -1;
    if (h->next->next == NULL)
        return 0;

    p = h->next->next;
    while (p != h) {
        q = p;
        p = p->next;
        q->next = h->next;
        h->next = q;
    }
    
}
```

#### 单链表的创建

（1）首插法：

1. 先建立一块空间，作为头指针，其存储地址为NULL表示为空表。
2. 再创建一块空间，连接到尾部，存储先前空间的NULL，头指针存储的地址变成该空间。
3. 以此类推……

<img src="https://gitee.com/you-xu2003/markdown-pic/raw/master/img/202303021900111.png" alt="image-20230302190009811" style="zoom:80%;" />

```c
void Create_L1(LinkList* L, int n)
{
    LinkList p;
    int i;
    L = (LinkList*)malloc(sizeof(LNode));
    L -> next = NULL;
    for(i=n; i>0; i--){
        p = (LinkList*)malloc(sizeof(LNode));
        scanf("%d", &(p->data));
        p -> next = L -> next;
        L -> next = p
    }
}
```

（2）尾插法：

<img src="https://gitee.com/you-xu2003/markdown-pic/raw/master/img/202303021908233.png" alt="image-20230302190846041" style="zoom:80%;" />

```c
void Create_L2(LinkList* L, int n)
{
    LinkList p;
    LinkList s; //不同于首插法，从后向前插入结点是根据自己申请的内存，而首插法是根据已有的首结点来链接新结点L始终不动，故需要新的辅助变量。
    L = (LinkList)malloc(sizeof(LNode));
    L -> next = NULL;
    s = L;
    for(i=1; i<n; i++){
        p = (LinkList)malloc(sizeof(LNode));
        scanf("%d",&(p->data));
        p -> next = NULL;
        s -> next = p;
        s = p;
    }
}
```

#### 链表的合并

设Pa,Pb分别为两个按升序排列的单链表的头指针，设计算法将二个单链表合并为一个按降序排列的单链表C ，要求利用原表的结点空间。



```c
void Merge(LinkList& La, LinkList& Lb, LinkList& Lc)
{
    pa = La->next;
    pb = Lb->next;
    Lc = pc = pa;
    while(pa!=NULL && pb!=NULL){
        if(pa->data<=pb->data){
            pc->next = pa;
            pc = pa;
            pa = pa->next;
        }
        else{
            pc->next = pb;
            pc = pb;
            pb = pb->next;
        }
    }
    pc->next = pa ? pa : pb;
    free(Lb);
}
```



### 2.4 一元多项式的表示与相加

#### 数组表示

将一元多项式的指数与数组下标一一对应，`A[i]`就是$x^i$项的系数。

问题一：求两个一元多项式的和。

简单的办法就是`A[i]+B[i]`就可以了。但是，对于相邻项指数相差过大的多项式，很多系数是0，为了不浪费存储，只存放系数非零项的系数和相应的指数。且系数非零项仍按指数升序排列方便运算实现。那么，我们可以用元组来替代数组表示多项式。例如$S_{2000}(x)=1+2x^{2000}$只存放指数为0和2000两项即可$S_{2000}=((1,0),(2,2000))$表示指数为零的项的系数为1，指数为2000的项的系数为2。

这样的话，我们就可以使用顺序存储结构存储这些元组

<img src="https://gitee.com/you-xu2003/markdown-pic/raw/master/img/202303072255082.png" alt="image-20230307225518735" style="zoom:80%;" />

定义抽象数据类型如下

```c++
define MAXSIZE　100
typedef struct
{
    int coef, exp;
}ElemType;
typedef struct
{
    ElemType elem[MAXSIZE];
    int length;
}SeqPoly;
```

#### 链表表示

链表中每个结点存储多项式中的一个非零项，包括系数和指数两个数据域以及一个指针域。排列按照一定的顺序进行排列。解决多项式问题建议使用链表。

```c++
typedef struct PolyNode *Polynomial;
struct PolyNode{
    int coef;
    int expon;
    Polynomial link;
}
```

#### 多项式求值

```c
ElemType Get_Value(ElemType x, Poly& p){
    q = p->next;
    ans = 0;
    while(q){
       ans += q->coef*pow(x, q->exp);
       q = q->next;
    }
    return ans;
}
```



#### 多项式的相加

相加的算法和合并链表的算法相似。相加过程：元组按照指数递减的顺序进行排列，从头开始，比较两多项式当前对应项的指数，选出指数较大的对应的元组；之后将**指数较大的元组的下一项**和原来的较小的元组比较...重复进行，再将剩余的项直接接到结果即可。

```c
/*自己写的*/
void add(Polynomial& La, Polynomial& Lb, Polynomial& Lc)
{
    pa = La->next;
    pb = Lb->next;
    Lc = pc = pa;
    while(pa && pb){
        if(pa->expon < pb->expon){
            pc->next = pa;
            pc = pa;
            pa = pa->next;
        }
        else if(pa->expon > pb->expon){
            pc->next = pb;
            pc = pb;
            pb = pb->next;
        }
        else{
            pa->coef = pa->coef + pb->coef;
            if(pa->coef != 0){
            	pc->next = pa;
                pa = pa->next;
            	pb = pb->next;
            }
            else{
                pa = pa->next;
                pb = pb->next;
            }
        }
    }
    pc->next = pa ? pa : pb;
    free(Lb);
}
```

```c
void add(poly& pa, poly& pb)
{
    poly qa, qb, q;
    qa = pa->next;
    q = pa;
    qb = pb->next;
    while(qa && qb){
        if(qa->exp < qb->exp){
            q = qa;qa = qa->next; 
        }
        else if(qa->exp == qb->exp)
        {
            sum = qa->coef + qb->coef;
            pb->next = qb->next;
            /*重置指针*/
            free(qb);
            qb = pb->next;
            if(sum == 0){
                q->next = qa->next;
                free(qa);
                qa = q->next;
            }
            else{
                pb->next = qb->next;
                qb->next = qa;
                q = qb;
                qb = qb->next;
            }
        }
    }
}
```

## 第三章 堆栈（栈）与队列

### 3.1 栈的概念

栈（stack），又名堆栈，是**限制在表的一端（表尾）进行插入和删除的线性表**。特点是先进后出。在计算机中使用一组地址连续的存储单元依次存储栈中的每一个数据元素，核心是数组。

<img src="https://gitee.com/you-xu2003/markdown-pic/raw/master/img/202303111840023.png" alt="image-20230311184014747" style="zoom:80%;" />                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      

栈的存储方式有：顺序型存储和链型存储。栈的主要操作有初始化空栈、入栈、出栈、判断栈是否是空栈、取栈顶数据元素等。**栈顶**是一个栈的标志，栈的主要操作均在栈顶进行，因此需要保存栈顶位置以方便操作进行。

保存栈顶的两种方法：

1. 实际的栈顶位置：栈顶元素在数组中的位置（位置就是对应的数组下标）。
2. 下一次入栈的位置：下一次插入到数组中的位置。

<img src="https://gitee.com/you-xu2003/markdown-pic/raw/master/img/202303111848438.png" alt="image-20230311184857158" style="zoom:80%;" />

保存栈顶位置的变量称为**栈顶指针**

**1. 栈顶指针指示栈顶的实际位置**

top = -1：空栈；

top = 0：一个元素

**2.栈顶指针指示下一次入栈的位置**

top = 0：空栈；

top = n：栈中有n个数据元素；

### 3.2 栈的定义

```c
#define MAXSIZE 1024
typedef struct
{
    elemType data[MAXSIZE];
    int top; //栈顶指针
}Stack;
```

初始化栈的栈顶指针应为`s.top = -1`

### 3.3 顺序栈的push

```c
bool InitStack(Stack &S)
{
    S.base = (ElemType*)malloc(STACK_INIT_SIZE*sizeof(Elemtype));
    if(!S.base)
        exit(OVERFLOW);
    S.top = -1;
    if(S.top<MAXSIZE-1)
        scanf("%d", &(S.data[++S.top]));
    else
        printf("OVERFLOW"); //表示栈满
}
```

### 3.4 顺序栈的Pop

很简单，将栈顶指针下移即可

```c
if(S.top>=0)
    S.top--;
```

### 3.5 链栈

**栈的定义**

```c
typedef struct node{
    int data;
    struct node* next;
}Node, *LinkList;
LinkList top; //栈顶指针
```

