# 数据结构与算法

## 第一章 绪论

### 1.1 数据结构的基本概念

​		**数据**：对客观事物的符号化表示，是计算机程序加工的原料，数据的基本单位是数据元素。

​		**数据结构**是相互存在一种或多种特定关系的数据元素的集合。有四种基本结构：（1）**集合** 结构中的数据元素没有关系；（2）**线性结构** 结构中的数据元素只有一个前驱或者后继（端节点除外）；（3）**树形结构** 数据元素的关系图满足图论的树图；（4）**图状结构（网状结构）** 数据元素之间存在着多个对多个的关系。

​		数据结构可以用关系图来表示，节点代表数据元素的有限集、边代表元素之间的关系、这种表示法表示的是数据结构的数学模型，称为**逻辑结构**。此外，数据结构在计算机中还要存储元素之间的关系，数据结构在计算机中的表示称为数据的**物理结构**。物理结构在计算机中有两种存储法：**顺序存储结构**与**链式存储结构**。顺序存储结构按照元素在存储器中的相对位置来进行存储，有顺序；链式存储结构中还要存储**指针**来表示元素之间的关系：

<img src="https://gitee.com/you-xu2003/markdown-pic/raw/master/img/202302211857451.png" alt="Alt" style="zoom:10%;" />

​		数据类型：可分为原子类型（整型、实型、字符型、枚举型）和结构类型。**抽象数据类型**是指一个数学迷行以及定义在该模型上的一组操作。

### 1.2 算法和算法分析

算法是对特定问题求解步骤的一种描述，是指令的有限序列。算法的五个特性：

1. 有穷性，一个算法必须在又穷的时间内完成，这里的有穷时间是针对人的可以接受的时间长度。
2. 确定性，不能产生二义性。
3. 可行性。
4. 输入。
5. 输出。

#### 1.2.1 算法的效率

（1）输入一个整数值N设计一个程序打印从0到N的所有整数值的程序，有以下两种方式：

```c
/*直接法*/
void printN(int N)
{
    int i;
    for(i=0; i<=N; i++){
        printf("%d\n", i);
    }
    return;
}
/*递归法*/
void printN(int N)
{
    if(N){
        printN(N-1);
        printf("%d\n", N);
    }
    return;
}
```

这两个实现方法实际上拥有不同的空间效率，递归的方法占用的空间实际上相当之大。

（2）写一个程序计算给定多项式$f(x)=\sum\limits_{i=0}^{9}a_ix^i$在某一定点的数值：

```c
double f1(int n, double a[], double x)
{
    int i;
    double p = a[0];
    for(i=1; i<=n; i++)
    {
        p += (a[i]*pow(x, i));
    }
    return p;    
}
```

将多项式$f(x)=a_0+a_1x=a_2x^2+...+a_nx^n$写成$f(x)=a_0+x(a_1+x(...(a_{n-1}+x(a_n))...))$可以将程序写成下面的样子

```c
double f2(int n, double a[], double x)
{
    int i;
    int p = a[n];
    for(i=n; i>0; i--){
        p = a[n-1] + p*x;
    }
    return p;
}
```

那么。这两种算法哪一个更好呢？判断一个算法“好不好”，主要看它的效率怎样，实际上，这第二种算法时间上的效率要优于第一种算法。我们可以用C中计时器加以验证：

```c
#include <stdio.h>
#include <time.h>

clock_t start, stop;
/* clock_t是clock()函数的返回值类型*/
double duration;

int main()
{
    /* 不在测试范围内的准备工作写到clock()调用之前 */
    start = clock(); // 开始计时
    MyFunction();
    stop = clock(); // 停止计时
    duration = ((double)(stop - start))/CLK_TCK; //CLK_TCK是机器自带常数，反映的是一秒之内计时器tick的次数
    return 0;
}
```

对于一些函数运行起来很快，甚至用不到一个tick，那么计算的结果都将是0。我们通过重复运行该函数的方法，累积出时间再除以运行次数

```c
#include<stdio.h>
#include<time.h>
#include<math.h>
clock_t start, stop;
double duration;
#define MAXK 1e7
int main()
{
    start = clock();
    for(i=0; i<MAXK; i++){
        f1(MAXN-1, a, 1.1);
    }
    stop = clock();
    duration = ((double)(stop-start))/CLK_TCK/MAXK;
    printf("ticks = %f\n", ticks);
    printf("duration = %6.2e\n", duration);
    /*f2同样*/
    return 0;
}
```

从理论上分析，第一种方法在循环中会计算$\dfrac{n^2+n}{2}$次乘法，而第二种方法只需要做n次乘法就够了，所以第二种方法优于第一种方法。

**算法效率的度量**：时间复杂度T(n)和空间复杂度S(n)

时间复杂度：
$$
T(n)=O(f(n))
$$
表示存在常数C>0，$n_0>0$使得当$n>n_0$时有$T(n)\leq Cf(n)$。对充分大的n而言$f(n)$是一个上界。算法执行的时间与$ O(f(n)) $成正比。决定T(n)的是控制语句`while`和`for`。**一个`for`循环的时间复杂度等于循环次数乘以循环体代码的复杂度；`if-else`结构的复杂度取决于if的条件判断复杂度和两个分支部分的复杂度，总体复杂度取三者中最大。**

**注：**

1. 在设计程序时，应尽量避免出现f(n)为指数函数、阶乘函数的算法。
2. 设计出复杂度为$O(n^2)$的算法时，可以去想一想是否可以将复杂度降为$O(n\log n)$。
3. $\log n$的底数无关紧要，不同的底数相差的只是倍数。

关于时间复杂度的性质有如下几条：
$$
\begin{align}
O(f(n)+g(n))&=max\{O(f(n)),O(g(n))\}\\
O(cf(n))&=O(f(n))\\
O(f(n))O(g(n))&=O(f(n)g(n))
\end{align}
$$
时间复杂度的例子会在以后设计算法的过程中一一计算。

求多项式第二个方法的时间复杂度$T(n)=C_1n^2+C_2n$，第二个方法的时间复杂度为$T(n)=Cn$。

空间复杂度：
$$
S(n)=O(f(n))
$$
一个算法在运行过程中临时占用存储空间大小的量度，在之后学习到的排序算法会有具体的讲解。

分析一般的算法效率时，我们经常关注两种复杂度：最坏情况复杂度和平均复杂度$T_{average}(n)<T_{worst}(n)$

### 1.3 抽象数据类型（Abstract Data Type）

描述数据类型的方法**不依赖于具体的实现**，只描述数据对象集和操作集具体是什么，不关心怎么做到的。

### 1.4 二分查找算法

给定N个从小到大排好序的整数序列`List[]`以及某待查找整数X，寻找X在List中的下标，即若有`List[i]=x`，则返回i；否则返回-1表示没有找到。二分法是先找到序列的中点List[M]，与X进行比较，若相等则返回中点下标；否则，若`List[M]>X`，则在左边的子序列中查找X；若`List[M]<X`，则在右边的子序列中查找X，不断的重复下去。

伪码描述：

```c
right = sizeof(arr)/sizeof(arr[0]) - 1;
left = 0;
while(right>left){
    mid = left + (right - left)/2; //寻找最中间的数
    if(x < arr[mid])
    {
        right = mid - 1;
    }
    else if(x > arr[mid]){
        left = mid + 1;
    }
    else if(x = arr[mid]){
        print(mid);
    }
}
if(right<left)
    return -1;
return 0;
```

该算法的最好情况是查找1次，最坏情况是查找的元素在最后。对于n个元素的状况：

1. 第1次二分剩下的元素：n/2
2. 第2次二分剩下的元素：n/4
3. ...
4. 第k次二分剩下的元素：n/2^k

最坏的情况剩下的元素为1，即$2^k=n$，$k=\log n$。空间复杂度，由于辅助空间是常数，故为$O(1)$。

## 第二章 线性表

### 2.1 线性表的定义

线性表就是线性的数据结构，应注意，线性表的数据元素必须**属于同一数据对象**，即具有相同特性。如字母表，统计表。

线性表的操作包括插入、删除、访问和查找，用程序实现线性表有两种方法，各有合适的适用范围。**顺序实现（顺序表）和链式实现（链表）**

### 2.2 线性表的顺序实现

顺序表通常用数组来表示，线性表的长度是可变的，故在C语言中，要用动态分配的一维数组。

```c
#define LIST_INIT_SIZE 100 //线性表存储空间的初始分配量
#define LISTINCREMENT  10 //线性表存储空间的分配增量
typedef struct{
    ElemType *elem; //存储空间基本地址
    int length; //当前长度
    int lengthsize; //当前分配的存储容量
}SqList;
```

为顺序表增加存储空间用`status`作为抽象的返回类型，用以说明函数运行的成功或失败状态。

```c
Status InitList_Sq(SqList &L)
{
	L.elem = (ElemType*)malloc(LIST_INIT_SIZE*sizeof(ElemType));
    if(!L.elem)
        exit(OVERFLOW); //操作系统无法为程序员申请一块这样的内存，会返回一个0，这块内存是不被允许访问的
    L.length = 0; //空表长度为0
    L.listsize = LIST_INIT_SIZE; // 初始存储容量
    rerurn OK;
}
```

**顺序表元素的访问：**

```c
L.elem[i-1] //访问链表中的第i个元素
```

**顺序表元素的插入：**

首先定义一个可插入顺序表的前提是要保证当前长度`L.length`小于当前分配的存储容量`L.listsize`

<img src="https://gitee.com/you-xu2003/markdown-pic/raw/master/img/202302231828275.png" style="zoom:50%;" />

想要在2、3之间插入元素25，采用引入辅助变量交换元素的方法空间复杂度大，也很复杂，采用**从后向前，将元素下移，直到把3的位置空出来留给25

```c++
Status ListInsert_Sq(SqList &L, int i, elemType e){
    if(i<1 || i>L.length-1) return ERROR; //超出索引值，不合法
    
    if(L.length>=L.listsize){ //当前存储空间已满，增加分配
        newbase = (ElemType*)realloc(L.elem, L.listsize+LISTINCREMENT)*sizeof(Elemtype));
    }
    
    if(!newbase)exit(OVERFLOW); //存储分配失败
    
    L.elem = newbase; //新基址
    L.listsize += LISTINCREMENT; //增加存储容量
}

q = &(L.elem[i-1]); //获取要插入的位置
for(int p=&(L.elem[L.length-1]); p>=q; --p){
    *(p+1) = *p;
}

*q = e; //插入e
++L.length; //表长加一

return OK;
```

**顺序表元素的删除**

删除第i个元素需要将从第i+1至第n个元素依次向前移动一个位置：

```c
Status ListDelete_Sq(SqList &L, int i, ElemType &e)
{
    if(i<=1 || (i>L.length))
        return Error; // 超出索引值，不合法
    
    int *p = &(L.elem[i-1]);
    e = *p; // 记录删除的值
    
   int* q = &(L.elem+L.length-1);
    for(++p; p<=q; p++){
        *(p-1) = *p;
    }
    
    --L.length;
    return OK;
}
```

**时间复杂度分析**

插入与删除算法耗费在对元素的移动上，移动元素的个数则取决于插入或删除元素的位置。

假设$p_i$是在第$i$个元素之前插入一个元素的概率，则在长度为n的线性表中插入一个元素时所需移动元素次数的期望值为
$$
\begin{equation}
E_{is}=\sum\limits_{i=1}^{n+1}p_i(n-i+1)
\end{equation}
$$
假设$q_i$是删除第$i$个元素的概率，则在长度为n的线性表中删除一个元素时所需移动次数的期望值为
$$
E_{dl}=\sum\limits_{i=1}^{n}q_i(n-i)
$$
通常情况下，在任何位置插入或删除元素的概率都是相等的，即
$$
p_i=\dfrac{1}{n+1}, \quad q_i=\dfrac{1}{n}
$$
化简期望：
$$
\begin{align}
E_{is}&=\dfrac{1}{n+1}\sum\limits_{i=1}^{n+1}(n-i+1)=\dfrac n2\\
E_{dl}&=\dfrac 1n\sum\limits_{i=1}^n(n-i)=\dfrac{n-1}2
\end{align}
$$
无论是插入还是删除，都平均需要移动n/2个元素，因此$T(n)=O(n)$。

**查找**

```c++
int ListSearch(SqList L, int e)
{
    int i;
    for(i=1; i<L.length; i++){
        if(L.elem[i-1] == e)
            rerurn i;
    }
        return -1;
}
```

该算法的时间复杂度为$O(n)$,如何进行算法的优化？只能从语句`i < L.length`入手，我们可以先将数组的元素整体向下平移一格，空出索引值为0的位置，并在此处填上要索引的值。

```c++
int ListSearch(SqList* L, int e)
{
    if (L -> length >= L -> listsize) {
        int* newbase = (int*)realloc(L -> elem,
            (L -> listsize + LISTINCREMENT) * sizeof(int));
        L->elem = newbase;
    }
    

    int* p = &(L->elem[L->length - 1]);
    for (p; p >= L->elem; p--) {
            *(p + 1) = *p;
        }
    L -> elem[0] = e;
    ++L -> length;
    int i;
    for (i = L -> length; L->elem[i] != e; i--);
    return i;
}
```

### 2.3 链表(Link List)

![image-20230227161932079](https://gitee.com/you-xu2003/markdown-pic/raw/master/img/202302271619265.png)





数据以及下一个存放地址的组合称为结点(node)，每个结点的地址是无规律的，只靠着地址将其串联起来。在单链表的索引中，取得第i个元素必须从头指针出发。

**头指针** 指向链表的第一个节点的结点称为头结点，头结点的指针域称为头指针。头结点可以不存放任何的数据信息，也可以存放链表的基本信息，头指针是必须存在的，而且一旦被头指针指向后，被头指针指向的结点就不允许进行删除、插入操作。当头指针为NULL（空）是，该链表为空表。

**单链表的存储结构**

```c++
typedef struct LNode{
    ElemType data; // 链表存储的数据
    struct LNode *next; // 指向下一个元素的指针
}LNode, *LinkList;
```

**单链表的存取**






$$

$$



