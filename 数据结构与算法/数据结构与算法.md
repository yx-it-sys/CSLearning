# 数据结构与算法

## 第一章 绪论

### 1.1 数据结构的基本概念

​		**数据**：对客观事物的符号化表示，是计算机程序加工的原料，数据的基本单位是数据元素。

​		**数据结构**是相互存在一种或多种特定关系的数据元素的集合。有四种基本结构：（1）**集合** 结构中的数据元素没有关系；（2）**线性结构** 结构中的数据元素只有一个前驱或者后继（端节点除外）；（3）**树形结构** 数据元素的关系图满足图论的树图；（4）**图状结构（网状结构）** 数据元素之间存在着多个对多个的关系。

​		数据结构可以用关系图来表示，节点代表数据元素的有限集、边代表元素之间的关系、这种表示法表示的是数据结构的数学模型，称为**逻辑结构**。此外，数据结构在计算机中还要存储元素之间的关系，数据结构在计算机中的表示称为数据的**物理结构**。物理结构在计算机中有两种存储法：**顺序存储结构**与**链式存储结构**。顺序存储结构按照元素在存储器中的相对位置来进行存储，有顺序；链式存储结构中还要存储**指针**来表示元素之间的关系：

<img src="https://gitee.com/you-xu2003/markdown-pic/raw/master/img/202302211857451.png" alt="Alt" style="zoom:10%;" />

​		数据类型：可分为原子类型（整型、实型、字符型、枚举型）和结构类型。**抽象数据类型**是指一个数学迷行以及定义在该模型上的一组操作。

### 1.2 算法和算法分析

算法是对特定问题求解步骤的一种描述，是指令的有限序列。算法的五个特性：

1. 有穷性，一个算法必须在又穷的时间内完成，这里的有穷时间是针对人的可以接受的时间长度。
2. 确定性，不能产生二义性。
3. 可行性。
4. 输入。
5. 输出。

**算法效率的度量**：时间复杂度T(n)和空间复杂度S(n)

时间复杂度：
$$
T(n)=O(f(n))
$$
算法执行的时间与$ O(f(n)) $成正比。决定T(n)的是控制语句`while`和`for`在设计程序时，应尽量避免出现f(n)为指数函数的算法。

关于时间复杂度的性质有如下几条：
$$
\begin{align}
O(f(n)+g(n))&=max\{O(f(n)),O(g(n))\}\\
O(cf(n))&=O(f(n))\\
O(f(n))O(g(n))&=O(f(n)g(n))
\end{align}
$$
时间复杂度的例子会在以后设计算法的过程中一一计算。

空间复杂度：
$$
S(n)=O(f(n))
$$
一个算法在运行过程中临时占用存储空间大小的量度，在之后学习到的排序算法会有具体的讲解。

## 第二章 线性表

### 2.1 线性表的定义

线性表就是线性的数据结构，应注意，线性表的数据元素必须**属于同一数据对象**，即具有相同特性。如字母表，统计表。

线性表的操作包括插入、删除、访问和查找，用程序实现线性表有两种方法，各有合适的适用范围。**顺序实现（顺序表）和链式实现（链表）**

### 2.2 线性表的顺序实现

顺序表通常用数组来表示，线性表的长度是可变的，故在C语言中，要用动态分配的一维数组。

```c
#define LIST_INIT_SIZE 100 //线性表存储空间的初始分配量
#define LISTINCREMENT  10 //线性表存储空间的分配增量
typedef struct{
    ElemType *elem; //存储空间基本地址
    int length; //当前长度
    int lengthsize; //当前分配的存储容量
}SqList;
```

为顺序表增加存储空间用`status`作为抽象的返回类型，用以说明函数运行的成功或失败状态。

```c
Status InitList_Sq(SqList &L)
{
	L.elem = (ElemType*)malloc(LIST_INIT_SIZE*sizeof(ElemType));
    if(!L.elem)
        exit(OVERFLOW); //操作系统无法为程序员申请一块这样的内存，会返回一个0，这块内存是不被允许访问的
    L.length = 0; //空表长度为0
    L.listsize = LIST_INIT_SIZE; // 初始存储容量
    rerurn OK;
}
```

顺序表元素的访问：

```c
L.elem[i-1] //访问链表中的第i个元素
```

顺序表元素的插入：

首先定义一个可插入顺序表的前提是要保证当前长度`L.length`小于当前分配的存储容量`L.listsize`

<img src="https://gitee.com/you-xu2003/markdown-pic/raw/master/img/202302231828275.png" style="zoom:50%;" />

想要在2、3之间插入元素25，采用引入辅助变量交换元素的方法空间复杂度大，也很复杂，采用**从后向前，将元素下移，直到把3的位置空出来留给25

```c++
Status ListInsert_Sq(SqList &L, int i, elemType e){
    if(i<1 || i>L.length-1) return ERROR; //超出索引值，不合法
    
    if(L.length>=L.listsize){ //当前存储空间已满，增加分配
        newbase = (ElemType*)realloc(L.elem, L.listsize+LISTINCREMENT)*sizeof(Elemtype));
    }
    
    if(!newbase)exit(OVERFLOW); //存储分配失败
    
    L.elem = newbase; //新基址
    L.listsize += LISTINCREMENT; //增加存储容量
}

q = &(L.elem[i-1]); //获取要插入的位置
for(int p=&(L.elem[L.length-1]); p>=q; --p){
    *(p+1) = *p;
}

*q = e; //插入e
++L.length; //表长加一

return OK;
```












$$

$$




