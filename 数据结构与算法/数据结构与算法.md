# 数据结构与算法

## 第一章 绪论

### 1.1 数据结构的基本概念

​		**数据**：对客观事物的符号化表示，是计算机程序加工的原料，数据的基本单位是数据元素。

​		**数据结构**是相互存在一种或多种特定关系的数据元素的集合。有四种基本结构：（1）**集合** 结构中的数据元素没有关系；（2）**线性结构** 结构中的数据元素只有一个前驱或者后继（端节点除外）；（3）**树形结构** 数据元素的关系图满足图论的树图；（4）**图状结构（网状结构）** 数据元素之间存在着多个对多个的关系。

​		数据结构可以用关系图来表示，节点代表数据元素的有限集、边代表元素之间的关系、这种表示法表示的是数据结构的数学模型，称为**逻辑结构**。此外，数据结构在计算机中还要存储元素之间的关系，数据结构在计算机中的表示称为数据的**物理结构**。物理结构在计算机中有两种存储法：**顺序存储结构**与**链式存储结构**。顺序存储结构按照元素在存储器中的相对位置来进行存储，有顺序；链式存储结构中还要存储**指针**来表示元素之间的关系：

<img src="https://gitee.com/you-xu2003/markdown-pic/raw/master/img/202302211857451.png" alt="Alt" style="zoom:10%;" />

​		数据类型：可分为原子类型（整型、实型、字符型、枚举型）和结构类型。**抽象数据类型**是指一个数学迷行以及定义在该模型上的一组操作。

### 1.2 算法和算法分析

算法是对特定问题求解步骤的一种描述，是指令的有限序列。算法的五个特性：

1. 有穷性，一个算法必须在又穷的时间内完成，这里的有穷时间是针对人的可以接受的时间长度。
2. 确定性，不能产生二义性。
3. 可行性。
4. 输入。
5. 输出。

#### 1.2.1 算法的效率

（1）输入一个整数值N设计一个程序打印从0到N的所有整数值的程序，有以下两种方式：

```c
/*直接法*/
void printN(int N)
{
    int i;
    for(i=0; i<=N; i++){
        printf("%d\n", i);
    }
    return;
}
/*递归法*/
void printN(int N)
{
    if(N){
        printN(N-1);
        printf("%d\n", N);
    }
    return;
}
```

这两个实现方法实际上拥有不同的空间效率，递归的方法占用的空间实际上相当之大。

（2）写一个程序计算给定多项式$f(x)=\sum\limits_{i=0}^{9}a_ix^i$在某一定点的数值：

```c
double f1(int n, double a[], double x)
{
    int i;
    double p = a[0];
    for(i=1; i<=n; i++)
    {
        p += (a[i]*pow(x, i));
    }
    return p;    
}
```

将多项式$f(x)=a_0+a_1x=a_2x^2+...+a_nx^n$写成$f(x)=a_0+x(a_1+x(...(a_{n-1}+x(a_n))...))$可以将程序写成下面的样子

```c
double f2(int n, double a[], double x)
{
    int i;
    int p = a[n];
    for(i=n; i>0; i--){
        p = a[n-1] + p*x;
    }
    return p;
}
```

那么。这两种算法哪一个更好呢？判断一个算法“好不好”，主要看它的效率怎样，实际上，这第二种算法时间上的效率要优于第一种算法。我们可以用C中计时器加以验证：

```c
#include <stdio.h>
#include <time.h>

clock_t start, stop;
/* clock_t是clock()函数的返回值类型*/
double duration;

int main()
{
    /* 不在测试范围内的准备工作写到clock()调用之前 */
    start = clock(); // 开始计时
    MyFunction();
    stop = clock(); // 停止计时
    duration = ((double)(stop - start))/CLK_TCK; //CLK_TCK是机器自带常数，反映的是一秒之内计时器tick的次数
    return 0;
}
```

对于一些函数运行起来很快，甚至用不到一个tick，那么计算的结果都将是0。我们通过重复运行该函数的方法，累积出时间再除以运行次数

```c
#include<stdio.h>
#include<time.h>
#include<math.h>
clock_t start, stop;
double duration;
#define MAXK 1e7
int main()
{
    start = clock();
    for(i=0; i<MAXK; i++){
        f1(MAXN-1, a, 1.1);
    }
    stop = clock();
    duration = ((double)(stop-start))/CLK_TCK/MAXK;
    printf("ticks = %f\n", ticks);
    printf("duration = %6.2e\n", duration);
    /*f2同样*/
    return 0;
}
```

从理论上分析，第一种方法在循环中会计算$\dfrac{n^2+n}{2}$次乘法，而第二种方法只需要做n次乘法就够了，所以第二种方法优于第一种方法。

**算法效率的度量**：时间复杂度T(n)和空间复杂度S(n)

时间复杂度：
$$
T(n)=O(f(n))
$$
表示存在常数C>0，$n_0>0$使得当$n>n_0$时有$T(n)\leq Cf(n)$。对充分大的n而言$f(n)$是一个上界。算法执行的时间与$ O(f(n)) $成正比。决定T(n)的是控制语句`while`和`for`。**一个`for`循环的时间复杂度等于循环次数乘以循环体代码的复杂度；`if-else`结构的复杂度取决于if的条件判断复杂度和两个分支部分的复杂度，总体复杂度取三者中最大。**

**注：**

1. 在设计程序时，应尽量避免出现f(n)为指数函数、阶乘函数的算法。
2. 设计出复杂度为$O(n^2)$的算法时，可以去想一想是否可以将复杂度降为$O(n\log n)$。
3. $\log n$的底数无关紧要，不同的底数相差的只是倍数。

关于时间复杂度的性质有如下几条：
$$
\begin{align}
O(f(n)+g(n))&=max\{O(f(n)),O(g(n))\}\\
O(cf(n))&=O(f(n))\\
O(f(n))O(g(n))&=O(f(n)g(n))
\end{align}
$$
时间复杂度的例子会在以后设计算法的过程中一一计算。

求多项式第二个方法的时间复杂度$T(n)=C_1n^2+C_2n$，第二个方法的时间复杂度为$T(n)=Cn$。

空间复杂度：
$$
S(n)=O(f(n))
$$
一个算法在运行过程中临时占用存储空间大小的量度，在之后学习到的排序算法会有具体的讲解。

分析一般的算法效率时，我们经常关注两种复杂度：最坏情况复杂度和平均复杂度$T_{average}(n)<T_{worst}(n)$

### 1.3 抽象数据类型（Abstract Data Type）

描述数据类型的方法**不依赖于具体的实现**，只描述数据对象集和操作集具体是什么，不关心怎么做到的。

### 1.4 二分查找算法

给定N个从小到大排好序的整数序列`List[]`以及某待查找整数X，寻找X在List中的下标，即若有`List[i]=x`，则返回i；否则返回-1表示没有找到。二分法是先找到序列的中点List[M]，与X进行比较，若相等则返回中点下标；否则，若`List[M]>X`，则在左边的子序列中查找X；若`List[M]<X`，则在右边的子序列中查找X，不断的重复下去。

伪码描述：

```c
right = sizeof(arr)/sizeof(arr[0]) - 1;
left = 0;
while(right>left){
    mid = left + (right - left)/2; //寻找最中间的数
    if(x < arr[mid])
    {
        right = mid - 1;
    }
    else if(x > arr[mid]){
        left = mid + 1;
    }
    else if(x = arr[mid]){
        print(mid);
    }
}
if(right<left)
    return -1;
return 0;
```

该算法的最好情况是查找1次，最坏情况是查找的元素在最后。对于n个元素的状况：

1. 第1次二分剩下的元素：n/2
2. 第2次二分剩下的元素：n/4
3. ...
4. 第k次二分剩下的元素：n/2^k

最坏的情况剩下的元素为1，即$2^k=n$，$k=\log n$。空间复杂度，由于辅助空间是常数，故为$O(1)$。

### 1.5 应用实例——最大子列和问题

给定N个整数的序列$\{A_1,A_2,...,A_N\}$，求函数$f(i, j)=\max\{0,\sum\limits_{k=1}^j A_k\}$的最大值。

算法一，暴力求解

```c
int MaxSubseqSum1(int A[], int N)
{
    int ThisSum, MaxSum = 0;
    int i, j, k;
    for(i=0; i<N; i++){
        
        for(j=i; j<N; j++){
            ThisSum = 0;
            for(k=i; k<=j; k++)
                ThisSum += A[k];
            
            if(ThisSum > MaxSum)
                MaxSum = ThisSum;
            
        }        
    }
 return MaxSum;   
}
```

这个算法是不可以被设计使用的，因为它的时间复杂度达到$O(N^3)$，当子列有10000个元素时，这个算法到了世界末日也完不成。可是，10000在大数据领域是一个微不足道的小数字。

该算法的缺陷在于再计算以相同开头的子列和时，有相当多的和式被重复计算了。改进这个算法就可以从避免重复计算入手

```c
int MaxSubseqSum1(int A[], int N)
{
    int ThisSum, MaxSum = 0;
    int i, j, k;
    for(i=0; i<N; i++){
        ThisSum = 0;
        for(j=i; j<N; j++){
            ThisSum += A[j];           
            if(ThisSum > MaxSum)
                MaxSum = ThisSum;            
        }        
    }
 return MaxSum;   
}
```

这个算法的时间复杂度降到了$O(N^2)$是个不小的飞跃，一般来讲时间复杂度为$N^2$的算法，常常有机会降到$N\log N$。下面来介绍优化算法——分治法。

<img src="https://gitee.com/you-xu2003/markdown-pic/raw/master/img/202303022328063.jpg" alt="微信图片_20230302232803" style="zoom: 50%;" />!]

```c
int Max3(int x, int y, int z)
{
    return x>y?(x>z?x:z):(y>z?y:z);
}
int DivCon(int list[], int left, int right)
{
    int MaxSumL, MaxSumR;//存放左右子问题的解
    int MaxSumBordL, MaxSumBordR; //存放跨分界线的结果
    int SumBordL, SumBordR;
    int center, i;
    
    if(left == right)
    {
        /*递归的终止条件，子列只有一个数字，此时，左等于右*/
        if(List[left]>0)
            return List[left];
        else
            return 0;
    }
    
    /*下面是分的过程*/
    center = (left+right)/2; //找到中分点
    MaxSumL = DivCon(List, left, center); //递归求两边子列的最大和
    MaxSumR = DivCon(List, center, right);
    
    /*下面求跨分界线的最大子列*/
    MaxSumBordL = 0;
    SumBordL = 0;
    
    for(i=center; i>=left; i--){
        SumBordL += list[i];
        if(SumBordL>MaxSumBordL)
            MaxSumBordl = SumBordL;
    }
    
    MaxSumBordR = 0;
    SumBordR = 0;
    for(i=center+1; i<=right; i++){
        SumBordR += list[i];
        if(SumBordR>MaxSumBordR)
            MaxSumBordR = SumBordR;
    }
    
    /*下面返回“治”的结果*/
    return Max3(MaxSumL, MaxSumR, MaxSumBordL+MaxSumBordR);
}

int MaxSeqSum3(int List[], int N)
{
    return DivCon(List, 0, N-1);
}
```

**分治法的时间复杂度**

由算法步骤可知：
$$
\begin{align}
T(N)&=2T(\frac N 2)+cN\\
T(1)&=O(1)
\end{align}
$$

$$
\begin{align}
T(N)&=2[2T(\dfrac N {2^2})+c\dfrac N 2]+cN\\
&=\cdots\\
&=2^kT(\frac{N}{2^k})+ckN
\end{align}
$$

当$2^k=N$时，
$$
T(N)=NO(1)+cN\log N
$$

$$
T(N)=cN\log N=O(N\log N)
$$

更快的算法：在线处理算法

```c
int MaxSubseqSum4(int A[], int N)
{
    int ThisSum, Maxsum;
    int i;
    ThisSum = MaxSum = 0;
    for(i=0; i<N; i++){
        ThisSum += A[i];
        if(ThisSum > MaxSum)
            MaxSum = ThisSum;
        else if(ThisSum<0) //无比精妙，如果ThisSum<0，那么不能使后面的部分和增大，后面的部分和是i++之后的下一步循环，加上这个ThisSum才是只有这一轮才有的子列，所以有必要对其讨论，然而这个ThisSum<0加上它已经比下一轮循环的子列和小了，因此没有讨论的必要了。
            ThisSum = 0;
    }
    return MaxSum;
}
```

$T(n)=O(N)$.

## 第二章 线性表

### 2.1 线性表的定义

线性表就是线性的数据结构，应注意，线性表的数据元素必须**属于同一数据对象**，即具有相同特性。如字母表，统计表。

线性表的操作包括插入、删除、访问和查找，用程序实现线性表有两种方法，各有合适的适用范围。**顺序实现（顺序表）和链式实现（链表）**

### 2.2 线性表的顺序实现

顺序表通常用数组来表示，线性表的长度是可变的，故在C语言中，要用动态分配的一维数组。

```c
#define LIST_INIT_SIZE 100 //线性表存储空间的初始分配量
#define LISTINCREMENT  10 //线性表存储空间的分配增量
typedef struct{
    ElemType *elem; //存储空间基本地址
    int length; //当前长度
    int lengthsize; //当前分配的存储容量
}SqList;
```

为顺序表增加存储空间用`status`作为抽象的返回类型，用以说明函数运行的成功或失败状态。

```c
Status InitList_Sq(SqList &L)
{
	L.elem = (ElemType*)malloc(LIST_INIT_SIZE*sizeof(ElemType));
    if(!L.elem)
        exit(OVERFLOW); //操作系统无法为程序员申请一块这样的内存，会返回一个0，这块内存是不被允许访问的
    L.length = 0; //空表长度为0
    L.listsize = LIST_INIT_SIZE; // 初始存储容量
    rerurn OK;
}
```

**顺序表元素的访问：**

```c
L.elem[i-1] //访问链表中的第i个元素
```

**顺序表元素的插入：**

首先定义一个可插入顺序表的前提是要保证当前长度`L.length`小于当前分配的存储容量`L.listsize`

<img src="https://gitee.com/you-xu2003/markdown-pic/raw/master/img/202302231828275.png" style="zoom:50%;" />

想要在2、3之间插入元素25，采用引入辅助变量交换元素的方法空间复杂度大，也很复杂，采用**从后向前，将元素下移，直到把3的位置空出来留给25

```c++
Status ListInsert_Sq(SqList &L, int i, elemType e){
    if(i<1 || i>L.length-1) return ERROR; //超出索引值，不合法
    
    if(L.length>=L.listsize){ //当前存储空间已满，增加分配
        newbase = (ElemType*)realloc(L.elem, L.listsize+LISTINCREMENT)*sizeof(Elemtype));
    }
    
    if(!newbase)exit(OVERFLOW); //存储分配失败
    
    L.elem = newbase; //新基址
    L.listsize += LISTINCREMENT; //增加存储容量
}

q = &(L.elem[i-1]); //获取要插入的位置
for(int p=&(L.elem[L.length-1]); p>=q; --p){
    *(p+1) = *p;
}

*q = e; //插入e
++L.length; //表长加一

return OK;
```

**顺序表元素的删除**

删除第i个元素需要将从第i+1至第n个元素依次向前移动一个位置：

```c
Status ListDelete_Sq(SqList &L, int i, ElemType &e)
{
    if(i<=1 || (i>L.length))
        return Error; // 超出索引值，不合法
    
    int *p = &(L.elem[i-1]);
    e = *p; // 记录删除的值
    
   int* q = &(L.elem+L.length-1);
    for(++p; p<=q; p++){
        *(p-1) = *p;
    }
    
    --L.length;
    return OK;
}
```

**时间复杂度分析**

插入与删除算法耗费在对元素的移动上，移动元素的个数则取决于插入或删除元素的位置。

假设$p_i$是在第$i$个元素之前插入一个元素的概率，则在长度为n的线性表中插入一个元素时所需移动元素次数的期望值为
$$
\begin{equation}
E_{is}=\sum\limits_{i=1}^{n+1}p_i(n-i+1)
\end{equation}
$$
假设$q_i$是删除第$i$个元素的概率，则在长度为n的线性表中删除一个元素时所需移动次数的期望值为
$$
E_{dl}=\sum\limits_{i=1}^{n}q_i(n-i)
$$
通常情况下，在任何位置插入或删除元素的概率都是相等的，即
$$
p_i=\dfrac{1}{n+1}, \quad q_i=\dfrac{1}{n}
$$
化简期望：
$$
\begin{align}
E_{is}&=\dfrac{1}{n+1}\sum\limits_{i=1}^{n+1}(n-i+1)=\dfrac n2\\
E_{dl}&=\dfrac 1n\sum\limits_{i=1}^n(n-i)=\dfrac{n-1}2
\end{align}
$$
无论是插入还是删除，都平均需要移动n/2个元素，因此$T(n)=O(n)$。

**查找**

```c++
int ListSearch(SqList L, int e)
{
    int i;
    for(i=1; i<L.length; i++){
        if(L.elem[i-1] == e)
            rerurn i;
    }
        return -1;
}
```

该算法的时间复杂度为$O(n)$,如何进行算法的优化？只能从语句`i < L.length`入手，我们可以先将数组的元素整体向下平移一格，空出索引值为0的位置，并在此处填上要索引的值。

```c++
int ListSearch(SqList* L, int e)
{
    if (L -> length >= L -> listsize) {
        int* newbase = (int*)realloc(L -> elem,
            (L -> listsize + LISTINCREMENT) * sizeof(int));
        L->elem = newbase;
    }
    

    int* p = &(L->elem[L->length - 1]);
    for (p; p >= L->elem; p--) {
            *(p + 1) = *p;
        }
    L -> elem[0] = e;
    ++L -> length;
    int i;
    for (i = L -> length; L->elem[i] != e; i--);
    return i;
}
```

### 2.3 链表(Link List)

![image-20230227161932079](https://gitee.com/you-xu2003/markdown-pic/raw/master/img/202302271619265.png)





数据以及下一个存放地址的组合称为结点(node)，每个结点的地址是无规律的，只靠着地址将其串联起来。在单链表的索引中，取得第i个元素必须从头指针出发。

**头指针** 指向链表的第一个节点的结点称为头结点，头结点的指针域称为头指针。头结点可以不存放任何的数据信息，也可以存放链表的基本信息，头指针是必须存在的，而且一旦被头指针指向后，被头指针指向的结点就不允许进行删除、插入操作。当头指针为NULL（空）是，该链表为空表。

**单链表的存储结构**

```c++
typedef struct LNode{
    ElemType data; // 链表存储的数据
    struct LNode *next; // 指向下一个元素的指针
}LNode, *LinkList;
```

**单链表的创建**

（1）首插法：

1. 先建立一块空间，作为头指针，其存储地址为NULL表示为空表。
2. 再创建一块空间，连接到尾部，存储先前空间的NULL，头指针存储的地址变成该空间。
3. 以此类推……

<img src="https://gitee.com/you-xu2003/markdown-pic/raw/master/img/202303021900111.png" alt="image-20230302190009811" style="zoom:80%;" />

```c
void Create_L1(LinkList* L, int n)
{
    LinkList p;
    int i;
    L = (LinkList)malloc(sizeof(LNode));
    L -> next = NULL;
    for(i=n; i>0; i--){
        p = (LinkList)malloc(sizeof(LNode));
        scanf("%d", &(p->data));
        p -> next = L -> next;
        L -> next = p
    }
}
```

（2）尾插法：

<img src="https://gitee.com/you-xu2003/markdown-pic/raw/master/img/202303021908233.png" alt="image-20230302190846041" style="zoom:80%;" />

```c
void Create_L2(LinkList* L, int n)
{
    LinkList p;
    LinkList s; //不同于首插法，从后向前插入结点是根据自己申请的内存，而首插法是根据已有的首结点来链接新结点L始终不动，故需要新的辅助变量。
    L = (LinkList)malloc(sizeof(LNode));
    L -> next = NULL;
    s = L;
    for(i=1; i<n; i++){
        p = (LinkList)malloc(sizeof(LNode));
        scanf("%d",&(p->data));
        p -> next = NULL;
        s -> next = p;
        s = p;
    }
}
```



**单链表的查找**

（1）按序号查找：链表的时间复杂度要大于数组的时间复杂度。

（2）按值查找：链表的时间复杂度等同于数组的时间复杂度。

```c
#define NULL 0
/*不代表头结点*/
LinkList search(LinkList h, int x)
{
    LinkList p;
    p = h;
    while(p != NULL){
        if(p -> data == x){
            return p;
        }
        else{
            p = p -> next;
        }
    }
    return NULL;
}
```

```c
#define NULL０
/*带表头结点*/
LinkList search(LinkList h, int x)
{
    LinkList p;
    p = h-> next;
    while(p!=NULL && p-> data != x){
   		p = p-> next;
    }
    return p;
}
```



**单链表的插入操作**

相比于数组，链表的插入操作不需要移动数据。

（1）在线性单链表的p结点之后插入一个新的结点x

```c
void insert(LinkList &p, int x)
{
    LinkList s;
    s = (LinkList)malloc(sizeof(LNode)); // 生成结点空间s
    s -> data = x; //插入的数据x放入结点空间s
    /*注意赋值的顺序*/
    s -> next = p -> next; //首先要将p原来的后继记录在插入元素x的结点空间
    p -> next = s; //再把元素x的结点空间的地址插入到p
}
```

（2）在头指针为h的带表头结点的单链表中数据元素a之后插入新的数据元素b

```c
void insert_S(Linklist &p, int a)
{
    p = search(h, a);
    if(p != NULL)
        insert(p, b);
}
```



**单链表的删除操作**

（1）删除单链表中p结点的直接后继结点

```c
void delete(LinkList &p)
{
    LinkList q;
    q = p -> next;
    p -> next = q -> next;
    free(q);
}
```

(2)在头指针为h的带表头结点的单链表中删除**元素x**

```c
void delete1(LinkList &h, int x)
{
    LinkList p = h -> next;
    q = h;
    while(p != NULL){
        if(p -> data == x){
            q -> next = p -> next;
            free(p);
            return;
        }
        else{
            q = p; 
            p = p -> next;
        }
    }
}
```

(3)删除重复结点：

在(2)的基础上稍作改动

```c
void delete3(LinkList &h, int x)
{
    LinkList p = h -> next;
    q = h;
    while(p != NULL)
    {
        if(p -> data == x){
            q -> next = p -> next;
            free(p);
            p = q -> next; // 继续走下去
        }
        else{
            q = p;
            p = p -> next;
        }
    }
}
```

**单链表的就地逆置**

<img src="https://gitee.com/you-xu2003/markdown-pic/raw/master/img/202303022253603.png" alt="image-20230302225325370" style="zoom:80%;" />

```c
void reverse(LinkList &h)
{
    LinkList p, q;
    if(h->next == NULL) return;
    if((h->next)->next == NULL) return;
    
    p = h->next->next;
    (h->next)->next = NULL; //执行Step 1
    while(p!=NULL){
        q = p;
        p = p->next; //移位，为下一周期执行做准备，停止条件为p != NULL
        q->next = h->next;
        h->next = q; //执行Step 2,特别注意12、13行的代码顺序
        
    }    
}
```








$$

$$



